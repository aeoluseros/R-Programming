x
x[["a",exact=FALSE]]
x<-list(aardvark=1:5,a=list(10,12,14),b=c(3.14,2.81))
x$a  #$sign do partial matching
x<-list(aardvark=1:5,ab=list(10,12,14),b=c(3.14,2.81))
x$a  #$sign do partial matching
x[["a"]]
x[["a",exact=FALSE]]
x<-list(aardvark=1:5)
x$a  #$sign do partial matching
x<-list(aardvark=1:5,aa=list(10,12,14),b=c(3.14,2.81))
x$a  #this will return NULL because
x<-list(aardvark=1:5,aa=list(10,12,14),b=c(3.14,2.81))
x$aa  #this will return NULL because
x<-list(aardvark=1:5,a=list(10,12,14),b=c(3.14,2.81))
x$aa  #this will return NULL because
bad<-is.na(x)
x<-c(1,2,NA,4,NA,5)
bad<-is.na(x)
bad
x[!bad]
x<-c(1,2,NA,4,NA,6)
bad<-is.na(x)
x[!bad]
good<-complete.cases(x,y)
y <- c("a","b",NA,"d",NA,"f")
good<-complete.cases(x,y)
good
x<-c(1,2,NA,4,NA,6)
y <- c("a","b",NA,"d",NA,"f")
good<-complete.cases(x,y)
good
?complete.cases
y <- c("a","b",NA,"d","f",NA,)
y <- c("a","b",NA,"d","f",NA)
good<-complete.cases(x,y)
good
x[good]
y[good]
good<-complete.cases(x,y)  #indexes that both x and y are TRUE
airquality
airquality[1:6,]
airquality[good,][1:6]
airquality[good,][1:6]
good<-complete.cases(airquality)
airquality[good,][1:6]
x<1:4; y<-6:9
x<-1:4; y<-6:9
###########practice#############
x+y
x+y;x/y;x>=2;x*y  #other languages need a loop to do this
x+y;x/y;x>=2;x*y;y==8  #other languages need a loop to do this
x.*y
x<-matrix(1:4,2,2); y<-matrix(rep(10,4),2,2)
x*y
x%*%y
x*y
x%/%
y
x*1.0%/%y
y%/%x
x*z
x<-matrix(1:4,2,2); y<-matrix(rep(10,4),2,2)
x*y   # multiply element by element
x%*%y  # matrix multiplication
z<-y%/%x  # matrix division
x*z
y
x%*%y  # matrix multiplication
z<-y%/%x  # matrix division
x*z
x%*%z
z<-y%/%x  # matrix division
x%*%z
x%*%z
x%*%z
x<-1:4; y<-6:9
z<-y%/%x  # matrix division
x%*%z
z
x
x<-matrix(1:4,2,2); y<-matrix(rep(10,4),2,2)
z<-y%/%x  # matrix division
x
y
x%*%z
z%*%x
x*z
z<-y%/%x  # matrix division
z%*%x
x/y
z<-y%/%x  # matrix division
?inverse
z%*%solve(x)
?ginv
install.package("ginv)
install.package("ginv")
install.packages("ginv")
install.package("MASS")
install.packages("MASS")
z%*%ginv(x)
library("MASS")
z%*%ginv(x)
z%*%solve(x)
z%*%x
?`%+%`
?`%+%`
?`%ã€%`
?`%/%`
1 %/% 0.2
1/0.2
0^3
x <- -1:12
x + 1
2 * x + 3
x %% 2
x + 1
2 * x + 3
x %/% 5
x
x<-1:15
if(x>4){
y<-10
}else{
y<-0
}
x<-10
if(x>4){
y<-10
}else{
y<-0
}
x<-10
if(x>4){
y<-10
}else if(x>6){
y<-0
}
if(x=10){
y<-11
}
if(x>10){
y<-9
}
x<-c('a','b','c','d')
x
count<-0
while(count<10){
print(count)
count<count+1
}
count<-0
while(count<10){
print(count)
count<-count+1
}
coin<-rbinom(1,1,0.5)
while(z>=3&&z<=10){   #conditions are alwys evaluated from left to right
print(z)
coin<-rbinom(1,1,0.5)
if(coin==1){
z<-z+1
}else{
z<-z-1
}
}
while(z>=3&&z<=10){   #conditions are alwys evaluated from left to right
print(z)
coin<-rbinom(1,1,0.5)
if(coin==1){
z<-z+1
}else{
z<-z-1
}
}
z<-5
while(z>=3&&z<=10){   #conditions are alwys evaluated from left to right
print(z)
coin<-rbinom(1,1,0.5)
if(coin==1){
z<-z+1
}else{
z<-z-1
}
}
x0<-1
tol<1e-8
repeat{
x1<-computeEstimate()
if(abs(x1-x0)<tol){
break
} else{
x0<x1
}
}
?computeEstimate
??computeEstimate
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
x0<-1
tol<1e-8
repeat{
x1<-rbinom(1,1,0.5)
if(abs(x1-x0)<tol){
break
} else{
x0<x1
}
}
x0<-1
tol<-1e-8
repeat{
x1<-rbinom(1,1,0.5)
if(abs(x1-x0)<tol){
break
} else{
x0<x1
}
}
x0<-1
tol<-1e-8
repeat{
x1<-rbinom(1,1,0.5)
print x1
if(abs(x1-x0)<tol){
break
} else{
x0<-x1
}
}
x0<-1
tol<-1e-8
repeat{
x1<-rbinom(1,1,0.5)
print(x1)
if(abs(x1-x0)<tol){
break
} else{
x0<-x1
}
}
x0<-1
tol<-1e-8
repeat{
x1<-rbinom(1,1,0.5)
print(x1)
if(abs(x1-x0)<tol){
break
} else{
x0<-x1
}
}
for(i in 1:100){
if(i<=20)
##skip the first 20 iterations
next
}
for(i in 1:100){
if(i<=20)
##skip the first 20 iterations
next
print(i)
}
for(i in 1:100){
if(i=20)
##skip the first 20 iterations
return 10
print(i)
}
add2<-function(x,y){
x+y
}
add2(3,5)
above<-functio(x,critical){
use<-x>n
x[use]
}
above<-functio(x,critical){
use<-x>n
x[use]
}
above<-functio(x,c){
above<-functio(x,c){
use<-x>c
x[use]
}
above10<-function(x){
use <- x>10
x[use]  #subset x
}
abovec<-functio(x,c){
use<-x>c
x[use]
}
abovec<-functio(x,c){
above<-function(x,c){
use<-x>c
x[use]
}
x<-1:12
above(x,10)
above<-function(x,c=3){
use<-x>c
x[use]
}
x<-1:12
above(x)
columnmean<-function(y){
nc<-ncol(y)  #number of columns
means<-numeric(nc)  #empty vector with all zeros
for(i in 1:nc){
means[i]<-mean(x[,i])
}
}
numeric(10)
columnmeans <- function(sapply(y,mean))
columnmeans <- function(y) sapply(y,mean))
columnmeans <- function(y) sapply(y,mean)
columnmean(airquality)
airquality
columnmean<-function(y){
nc<-ncol(y)  #number of columns
means<-numeric(nc)  #empty vector with all zeros
for(i in 1:nc){
means[i]<-mean(y[,i])
}
}
airquality
columnmean(airquality)
columnmeans(airquality)
columnmean(airquality)
columnmean<-function(y){
nc<-ncol(y)  #number of columns
means<-numeric(nc)  #empty vector with all zeros
for(i in 1:nc){
means[i]<-mean(y[,i])
}
means
}
columnmean(airquality)
columnmeans(airquality)
columnmean<-function(y,removeNA=TRUE){
nc<-ncol(y)  #number of columns
means<-numeric(nc)  #empty vector with all zeros
for(i in 1:nc){
means[i]<-mean(y[,i],na.rm=removeNA)
}
means
}
columnmean(airquality)
columnmeans <- function(y) sapply(y,mean(na.rm=TRUE))  #same function
columnmeans(airquality)
columnmeans <- function(y) sapply(y,mean(y,na.rm=TRUE))  #same function
columnmeans(airquality)
?sapply
columnmeans <- function(y) sapply(complete.cases(y),mean)  #same function
columnmeans(airquality)
columnmeans <- function(y) sapply(y[complete.cases(y)],mean)  #same function
columnmeans(airquality)
columnmeans <- function(y) sapply(y[,complete.cases(y)],mean)  #same function
columnmeans(airquality)
complete.cases(y)
complete.cases(airquality)
columnmeans <- function(y) sapply(y[complete.cases(y),],mean)  #same function
columnmeans(airquality)
formals(file)
formals(mean)
args(lm)
lm
formals(lm)
f<-function(a,b){
print(a)
print(b)
}
f(45)
myplot<-function(x,y,type="l",...){
plot(x,y,type=type,...)
}
mean
args(paste)
args(cat)
paste("a","b",sep=":")
paste("a","b",se=":")
c<-paste("a","b",sep=":")
c
c<-cat("a","b",sep=":")
d<-cat("a","b",sep=":")
d
print(c)
c<-paste("a","b",sep=":")
print(c)
print("c")
print(paste("a","b",sep=":"))
lm<-function(x) {x*x}
lm
search(lm)
search()
rm(lm)
lm
rm(lm)
lm
f<-function(x,y){
x^2+y/z
}
f(2,3)
rm(z)
f(2,3)
rm(z)
z<-2
f(2,3)
rm(z)
f(2,3)
z<-2
f(2,3)
search()  # the search list when R tries to find a value
?search
stats.lm
stats::lm
stats::lm()
make.power<-function(n){
pow<-function(x){
x^n
}
pow
}
cube<-make.power(3)
cube<-make.power(3)
cube
cube<-make.power(3)
make.power<-function(n){
pow<-function(x){
x^n
}
pow
}
cube<-make.power(3)
square<-make.power(2)
cube(3)
square(5)
environment(cube)
ls(environment(cube))
?ls
objects(environment(cube))
get("n",environment(cube))
?get
y<-10
f<-function(x){
y<-2
y^2+g(x)
}
g<-function(x){
x*y
}
f(3)
?cov_met
?cov.wt
setwd("D:\\study\\DataScience")
library(dplyr)
chicago<-readRDS("./GetAndCleanData/chicago.rds")
head(chicago)
dim(chicago)
str(chicago)
#select
head(select(chicago,city:dptp)) #such expression as city:dptp are normally not be able to use in other functions, but you can use it in the select function
head(select(chicago,-(city:dptp)))
i<-match("city",names(chicago))
j<-match("dptp",names(chicago))
head(chicago[,-(i:j)])  #without select, we could only use integer indecxes
#filter #same as select, we could directly refer to the variable names
chic.f<-filter(chicago,pm25tmean2>30) #directly refer to the variable names
head(chic.f,10)
dim(chic.f)
chic.f<-filter(chicago,pm25tmean2>30 & tmpd>80)
dim(chic.f)
#arrange
chicago<-arrange(chicago,date) #without arrange, this ordering would be hard to realize
head(chicago)
tail(chicago)
chicago<-arrange(chicago,desc(date))
head(chicago)
tail(chicago)
#rename
chicago<-rename(chicago,pm25=pm25tmean2,dewpoint=dptp)
head(chicago)
#mutate --> transform exsiting variables or to create new variables
#create a new variable
chicago<-mutate(chicago,pm25detrend=pm25-mean(pm25,na.rm=TRUE))
head(select(chicago, pm25, pm25detrend))
#group_by - split a data frame according to certain categorical variables
#first use mutate to create a categorical variable
chicago<-mutate(chicago, tempcat=factor(1*(tmpd>80),labels=c("cold","hot")))
head(chicago)
summarize(hotcold, pm25=mean(pm25),o3=max(o3tmean2),no2=median(no2tmean2))
#summarize each year
#first use mutate to create a categorical variable
chicago<-mutate(chicago,year=as.POSIXlt(date)$year+1900)
head(chicago)
years<-group_by(chicago,year)
summarize(years,pm25=mean(pm25,na.rm=TRUE),o3=mean(o3tmean2),no2=median(no2tmean2))
#pipeline operator %>% -- chain operators together
months<-chicago %>% mutate(month=as.POSIXlt(date)$mon+1) %>% group_by(month) %>% summarize(pm25=mean(pm25,na.rm=TRUE),o3=max(o3tmean2),no2=median(no2tmean2))
####dplyr could be used for data.table, SQL interface for relational databases via the DBI package
hotcold[is.na(hotcold$tempcat),] #one NA
#the idea is that you that a date set and you feed through a pipeline of operations to create a new data set
#summarize
head(years)
hotcold<-group_by(chicago,tempcat)
