}
if(x=10){
y<-11
}
if(x>10){
y<-9
}
x<-c('a','b','c','d')
x
count<-0
while(count<10){
print(count)
count<count+1
}
count<-0
while(count<10){
print(count)
count<-count+1
}
coin<-rbinom(1,1,0.5)
while(z>=3&&z<=10){   #conditions are alwys evaluated from left to right
print(z)
coin<-rbinom(1,1,0.5)
if(coin==1){
z<-z+1
}else{
z<-z-1
}
}
while(z>=3&&z<=10){   #conditions are alwys evaluated from left to right
print(z)
coin<-rbinom(1,1,0.5)
if(coin==1){
z<-z+1
}else{
z<-z-1
}
}
z<-5
while(z>=3&&z<=10){   #conditions are alwys evaluated from left to right
print(z)
coin<-rbinom(1,1,0.5)
if(coin==1){
z<-z+1
}else{
z<-z-1
}
}
x0<-1
tol<1e-8
repeat{
x1<-computeEstimate()
if(abs(x1-x0)<tol){
break
} else{
x0<x1
}
}
?computeEstimate
??computeEstimate
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
rbinom(1,1,0.5)
x0<-1
tol<1e-8
repeat{
x1<-rbinom(1,1,0.5)
if(abs(x1-x0)<tol){
break
} else{
x0<x1
}
}
x0<-1
tol<-1e-8
repeat{
x1<-rbinom(1,1,0.5)
if(abs(x1-x0)<tol){
break
} else{
x0<x1
}
}
x0<-1
tol<-1e-8
repeat{
x1<-rbinom(1,1,0.5)
print x1
if(abs(x1-x0)<tol){
break
} else{
x0<-x1
}
}
x0<-1
tol<-1e-8
repeat{
x1<-rbinom(1,1,0.5)
print(x1)
if(abs(x1-x0)<tol){
break
} else{
x0<-x1
}
}
x0<-1
tol<-1e-8
repeat{
x1<-rbinom(1,1,0.5)
print(x1)
if(abs(x1-x0)<tol){
break
} else{
x0<-x1
}
}
for(i in 1:100){
if(i<=20)
##skip the first 20 iterations
next
}
for(i in 1:100){
if(i<=20)
##skip the first 20 iterations
next
print(i)
}
for(i in 1:100){
if(i=20)
##skip the first 20 iterations
return 10
print(i)
}
add2<-function(x,y){
x+y
}
add2(3,5)
above<-functio(x,critical){
use<-x>n
x[use]
}
above<-functio(x,critical){
use<-x>n
x[use]
}
above<-functio(x,c){
above<-functio(x,c){
use<-x>c
x[use]
}
above10<-function(x){
use <- x>10
x[use]  #subset x
}
abovec<-functio(x,c){
use<-x>c
x[use]
}
abovec<-functio(x,c){
above<-function(x,c){
use<-x>c
x[use]
}
x<-1:12
above(x,10)
above<-function(x,c=3){
use<-x>c
x[use]
}
x<-1:12
above(x)
columnmean<-function(y){
nc<-ncol(y)  #number of columns
means<-numeric(nc)  #empty vector with all zeros
for(i in 1:nc){
means[i]<-mean(x[,i])
}
}
numeric(10)
columnmeans <- function(sapply(y,mean))
columnmeans <- function(y) sapply(y,mean))
columnmeans <- function(y) sapply(y,mean)
columnmean(airquality)
airquality
columnmean<-function(y){
nc<-ncol(y)  #number of columns
means<-numeric(nc)  #empty vector with all zeros
for(i in 1:nc){
means[i]<-mean(y[,i])
}
}
airquality
columnmean(airquality)
columnmeans(airquality)
columnmean(airquality)
columnmean<-function(y){
nc<-ncol(y)  #number of columns
means<-numeric(nc)  #empty vector with all zeros
for(i in 1:nc){
means[i]<-mean(y[,i])
}
means
}
columnmean(airquality)
columnmeans(airquality)
columnmean<-function(y,removeNA=TRUE){
nc<-ncol(y)  #number of columns
means<-numeric(nc)  #empty vector with all zeros
for(i in 1:nc){
means[i]<-mean(y[,i],na.rm=removeNA)
}
means
}
columnmean(airquality)
columnmeans <- function(y) sapply(y,mean(na.rm=TRUE))  #same function
columnmeans(airquality)
columnmeans <- function(y) sapply(y,mean(y,na.rm=TRUE))  #same function
columnmeans(airquality)
?sapply
columnmeans <- function(y) sapply(complete.cases(y),mean)  #same function
columnmeans(airquality)
columnmeans <- function(y) sapply(y[complete.cases(y)],mean)  #same function
columnmeans(airquality)
columnmeans <- function(y) sapply(y[,complete.cases(y)],mean)  #same function
columnmeans(airquality)
complete.cases(y)
complete.cases(airquality)
columnmeans <- function(y) sapply(y[complete.cases(y),],mean)  #same function
columnmeans(airquality)
formals(file)
formals(mean)
args(lm)
lm
formals(lm)
f<-function(a,b){
print(a)
print(b)
}
f(45)
myplot<-function(x,y,type="l",...){
plot(x,y,type=type,...)
}
mean
args(paste)
args(cat)
paste("a","b",sep=":")
paste("a","b",se=":")
c<-paste("a","b",sep=":")
c
c<-cat("a","b",sep=":")
d<-cat("a","b",sep=":")
d
print(c)
c<-paste("a","b",sep=":")
print(c)
print("c")
print(paste("a","b",sep=":"))
lm<-function(x) {x*x}
lm
search(lm)
search()
rm(lm)
lm
rm(lm)
lm
f<-function(x,y){
x^2+y/z
}
f(2,3)
rm(z)
f(2,3)
rm(z)
z<-2
f(2,3)
rm(z)
f(2,3)
z<-2
f(2,3)
search()  # the search list when R tries to find a value
?search
stats.lm
stats::lm
stats::lm()
make.power<-function(n){
pow<-function(x){
x^n
}
pow
}
cube<-make.power(3)
cube<-make.power(3)
cube
cube<-make.power(3)
make.power<-function(n){
pow<-function(x){
x^n
}
pow
}
cube<-make.power(3)
square<-make.power(2)
cube(3)
square(5)
environment(cube)
ls(environment(cube))
?ls
objects(environment(cube))
get("n",environment(cube))
?get
y<-10
f<-function(x){
y<-2
y^2+g(x)
}
g<-function(x){
x*y
}
f(3)
?cov_met
?cov.wt
package(kernlab)
library(kernlab)
head(spam)
??spam
spam
data(spam)
spam
head(spam)
head(spam)
?density
plot(density(spam$your[spam$type="nonspam"]),col="blue",main="",xlab="Frequency of 'your'")
plot(density(spam$your[spam$type=="nonspam"]),col="blue",main="",xlab="Frequency of 'your'")
lines(density(spam$your[spam$type=="spam"]),col="red")
dim(spam)
abline(v=0.5,col="black")
prediction<-ifelse(spam$your>0.5,"spam","nonspam")
table(prediction,spam$type)/length(spam$type)
library(kernlab);data(spam)
?Data
?data
smallSpam<-spam[sample(dim(spam)[1],size=10),]
smallSpam
spamLabel<-(smallSpam$type=="spam")*1+1
spamLabel
plot(smallSpam$capitalAve,col=spamLabel)
smallSpam$capitalAve
spamLabel<-(smallSpam$type=="spam")+1
spamLabel
rm(spamLabel)
spamLabel<-(smallSpam$type=="spam")+1
spamLabel
plot(smallSpam$capitalAve,col=spamLabel)
plot(smallSpam$capitalAve,col=spamLabel,pch=19)
?table
rule1<-function(x){
prediction<-rep(NA,length(x))
prediction[x>2.7]<-"spam"
prediction[x<2.40]<-"nonspam"
prediction[x>=2.40&x<=2.45]<-"spam"
prediction[x>2.45&x<=2.70]<-"nonspam"
return(prediction)
}
table(rule1(smallSpam$capitalAve),samllSpam$type)
set.seed(333)
smallSpam<-spam[sample(dim(spam)[1],size=10),]
spamLabel<-(smallSpam$type=="spam")+1
plot(smallSpam$capitalAve,col=spamLabel,pch=19)
#capitalAve>2.7 = "spam", capitalAve<2.4 = "nonspam"; capitalAve between 2.40 and 2.45 = "spam"; capitalAve between 2.45 and 2.7 = "nonspam"
table(rule1(smallSpam$capitalAve),samllSpam$type)
table(rule1(smallSpam$capitalAve),smallSpam$type)
smallSpam$type
rule1(smallSpam$capitalAve)
rule2<-function(x){
prediction<-rep(NA,length(x))
prediction[x>2.8]<-"spam"
prediction[x<=2.8]<-"nonspam"
return(prediction)
}
table(rule2(smallSpam$capitalAve),smallSpam$type)
table(rule1(spam$capitalAve),spam$type)
table(rule2(spam$capitalAve),spam$type)
sum(rule1(spam$capitalAve)==spam$type)
sum(rule2(spam$capitalAve)==spam$type)
?morlet
??morlet
??wmtsa
library(wmtsa)
?wmtsa
？wavVar
?wavVar
wavelet.plot
?wavelet.plot
library(dplR)
library(dplR)
?wavelet.plot
setwd("D:\\study\\DataScience")
library(faraway)
data(breaking)
breaking
matrix(breaking$supplier,4,4)
plot(y ~ operator + day + supplier, breaking)
plot(y ~ operator + day + supplier, breaking)
plot(y ~ operator + day + supplier, breaking)
g <- lm(y ~ operator + day + supplier, breaking)
anova(g)
plot(y ~ operator + day + supplier, breaking)
anova(lm(y ~ day + supplier + operator, breaking))
plot(g$fit,g$res,xlab="Fitted",ylab="Residuals")
qqnorm(g$res,ylab="Residuals")
summary(g)
qtukey(0.95,4,6)*55.7/sqrt(2)
qtukey(0.95,4,6)/sqrt(2)*55.7
scoefs <- c(0,g$coef[8:10])
?outer
outer(scoefs,scoefs,"-")
sweep(scoefs,scoefs,"-")
?sweep
?outer
qtukey(0.95,4,6)/sqrt(2)*55.7
pairdiff<-outer(scoefs,scoefs,"-")
abs(pairdiff)-192.8173
?iff
?iif
?ifelse
ifelse(abs(pairdiff)-192.8173>0,TRUE,0)
ifelse(abs(pairdiff)-192.8173>0,"TRUE","FALSE")
ifelse(abs(pairdiff)-192.8173>0,"T","F")
gr <- lm(y ~ supplier,breaking)
(summary(gr)$sig/summary(g)$sig)ˆ2
(summary(gr)$sig/summary(g)$sig)^2
summary(gr)$sig
summary(gr)
names(gr)
(summary(gr)$sig/summary(g)$sig)^2   #efficiency =
gr <- lm(y ~ supplier+operator,breaking)
(summary(gr)$sig/summary(g)$sig)^2
gr <- lm(y ~ supplier+day,breaking)
(summary(gr)$sig/summary(g)$sig)^2   #
data(rabbit)
rabbit
data(rabbit)
rabbit
matrix(rabbit$treat,nrow=3)
matrix(rabbit$treat,nrow=10)
dim(rabbit)
rabbit
matrix(rabbit$treat,nrow=3)
matrix(rabbit$treat,nrow=3)
t(matrix(rabbit$treat,nrow=3))
plot(gain ~ block + treat, rabbit)
plot(gain ~ block + treat, rabbit)
t(matrix(rabbit$treat,nrow=3))
g <- lm(gain ~ block+treat,data=rabbit)
anova(g)
anova(lm(gain ~ treat+block,data=rabbit))
plot(g$fitted,g$res,xlab="Fitted",ylab="Residuals")
qqnorm(g$res)
tcoefs <- c(0,g$coef[11:15])
g$coef
outer(tcoefs,tcoefs,"-")
summary(g)
sqrt((2*3)/(2*6))*3.17
sqrt((2*3)/(2*6))*3.17   #
summary(g)
qtukey(0.95,6,15)
abs(outer(tcoefs,tcoefs,"-")) > 7.27
abs(pairdiff)>192.81730
abs(outer(tcoefs,tcoefs,"-")) > 7.27
abs(outer(tcoefs,tcoefs,"-")) > 7.27   #Only the e-f difference is significant.
gr <- lm(gain ~ treat,rabbit)
(summary(gr)$sig/summary(g)$sig)^2
penicillin
matrix(breaking$supplier,4,4)
matrix(breaking$supplier,4,4)
breaking
7 + combn(7,2)
combn(7,2)
permn(3)
combn(3, 2)
choose(5, 2)
7 + choose(7,2)
#3-way: choose(7,3)
choose(7,3)
data(speedo)
speedo
g <- lm(y ~ .,speedo)
summary(g)
model.matrix(g)
summary(g)
model.matrix(g)
qqnorm(g$res) #Because the data are integers and the fitted values turn out to integers also, some
plot(g$fit,g$res,xlab="Fitted",ylab="Residuals",main="Residual-Fitted plot")
qqnorm(g$res) #Because the data are integers and the fitted values turn out to integers also, some
qnorm(1:15/16)
?qnorm
15/16
qnorm(1:15/16)
coef <- g$coef[-1]
i <- order(coef)
plot(qnorm(1:15/16),coef[i],type="n",xlab="Normal Quantiles",ylab="Effects")
text(qnorm(1:15/16),coef[i],names(coef)[i])
speedo
model.matrix(g)  #We see that "+" is coded as 0 and "-" is coded as 1 (ASCII alphabet).
summary(g)
coef <- abs(coef)
i <- order(coef)
plot(qnorm(16:30/31),coef[i],type="n",xlab="Half-Normal Quantiles",ylab="Effects")
text(qnorm(16:30/31),coef[i],names(coef)[i])
